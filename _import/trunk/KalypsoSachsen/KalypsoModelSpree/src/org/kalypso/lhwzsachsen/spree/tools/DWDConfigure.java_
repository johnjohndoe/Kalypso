/*
 * --------------- Kalypso-Header
 * 
 * This file is part of kalypso. Copyright (C) 2004, 2005 by:
 * 
 * Technical University Hamburg-Harburg (TUHH) Institute of River and coastal engineering Denickestr. 22 21073 Hamburg,
 * Germany http://www.tuhh.de/wb
 * 
 * and
 * 
 * Bjoernsen Consulting Engineers (BCE) Maria Trost 3 56070 Koblenz, Germany http://www.bjoernsen.de
 * 
 * This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General
 * Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * 
 * Contact:
 * 
 * E-Mail: belger@bjoernsen.de schlienger@bjoernsen.de v.doemming@tuhh.de
 * 
 * ----------------------------------------------------------------------
 */
package org.kalypso.lhwzsachsen.spree.tools;

import java.io.File;
import java.io.FileWriter;
import java.io.Writer;
import java.net.URL;
import java.util.List;

import javax.xml.bind.Marshaller;

import org.apache.commons.io.IOUtils;
import org.kalypso.contribs.java.net.IUrlCatalog;
import org.kalypso.contribs.java.net.MultiUrlCatalog;
import org.kalypso.dwd.DWDRaster;
import org.kalypso.dwd.DWDRasterGeoLayer;
import org.kalypso.dwd.DWDRasterHelper;
import org.kalypso.dwd.RasterPart;
import org.kalypso.dwd.dwdzml.DwdzmlConf;
import org.kalypso.dwd.dwdzml.ObjectFactory;
import org.kalypso.dwd.dwdzml.DwdzmlConfType.TargetType;
import org.kalypso.dwd.dwdzml.DwdzmlConfType.TargetType.MapType;
import org.kalypso.dwd.schema.UrlCatalogDWD;
import org.kalypso.lhwzsachsen.spree.SpreeUrlCatalog;
import org.kalypso.ogc.gml.serialize.GmlSerializer;
import org.kalypso.ogc.gml.typehandler.GM_ObjectTypeHandler;
import org.kalypso.ogc.sensor.deegree.ObservationLinkHandler;
import org.kalypso.ogc.sensor.status.KalypsoStati;
import org.kalypso.zml.obslink.TimeseriesLinkType;
import org.kalypsodeegree.model.feature.Feature;
import org.kalypsodeegree.model.feature.FeatureType;
import org.kalypsodeegree.model.feature.GMLWorkspace;
import org.kalypsodeegree.model.geometry.GM_Surface;
import org.kalypsodeegree_impl.extension.ITypeRegistry;
import org.kalypsodeegree_impl.extension.MarshallingTypeRegistrySingleton;
import org.kalypsodeegree_impl.gml.schema.GMLSchemaCatalog;
import org.kalypsodeegree_impl.gml.schema.schemata.DeegreeUrlCatalog;
import org.kalypsodeegree_impl.gml.schema.schemata.UrlCatalogUpdateObservationMapping;
import org.kalypsodeegree_impl.tools.GeometryUtilities;

/**
 * TODO: rework... start as IApplication or as junit plug-in test instead. Diese Klasse ist ein Werkzeug, um die
 * Zuordnung zwischen Rasterzellen des DWD-Rasters und den Niederschlagsgebieten zu generiernen.
 * <p>
 * Optional kann das Raster auch als GML (Polygon-Themen) ausgegeben werden.
 * </p>
 * <p>
 * Liest resources/dwd/lm2_inv_slug und resources/dwd/modell.gml
 * </p>
 * <p>
 * Schreibt C:/tmp/dwdConf.xml
 * </p>
 * 
 * @author doemming (16.06.2005)
 * @author belger Adaptiert für die Spree Februar 2006
 */
public class DWDConfigure
{
  /**
   * <p>
   * Synopsis: DWDConfigureTest -rasteroutput rasterfilename.gml
   * </p>
   * <p>
   * If -rasteroutput is not specified, no raster will be written (faster!)
   * </p>
   * 
   * @throws Exception
   */
  public static void main( final String[] args ) throws Exception
  {
    final ITypeRegistry registry = MarshallingTypeRegistrySingleton.getTypeRegistry();
    registry.registerTypeHandler( new ObservationLinkHandler() );
    registry.registerTypeHandler( new GM_ObjectTypeHandler( "PointPropertyType", GeometryUtilities.getPointClass() ) );
    registry.registerTypeHandler( new GM_ObjectTypeHandler( "MultiPointPropertyType", GeometryUtilities.getMultiPointClass() ) );

    registry.registerTypeHandler( new GM_ObjectTypeHandler( "LineStringPropertyType", GeometryUtilities.getLineStringClass() ) );
    registry.registerTypeHandler( new GM_ObjectTypeHandler( "MultiLineStringPropertyType", GeometryUtilities.getMultiLineStringClass() ) );

    registry.registerTypeHandler( new GM_ObjectTypeHandler( "PolygonPropertyType", GeometryUtilities.getPolygonClass() ) );
    registry.registerTypeHandler( new GM_ObjectTypeHandler( "MultiPolygonPropertyType", GeometryUtilities.getMultiPolygonClass() ) );

    // initalize urlcatalogs
    final MultiUrlCatalog multiCatalog = new MultiUrlCatalog( new IUrlCatalog[] { new SpreeUrlCatalog(), new UrlCatalogDWD(), new UrlCatalogUpdateObservationMapping(), new DeegreeUrlCatalog() } );
    final File cache = new File( "C:\\TMP\\schemaCatalog" );
    if( !cache.exists() )
      cache.mkdirs();
    GMLSchemaCatalog.init( multiCatalog, cache );

    // LM2:
    final URL lmBaseURL = DWDConfigure.class.getResource( "../resources/dwd/lm2_inv_slug" );

    final File fileDwdZmlN = new File( "C:\\TMP\\dwdZmlConf.xml" );

    createBaseRasterDWDRaster( args, lmBaseURL, fileDwdZmlN );
  }

  /**
   * generate raster as polygon-gml and create raster-mapping configuration
   * 
   * @param fileDwdZmlN
   * @throws Exception
   */
  public static void createBaseRasterDWDRaster( final String args[], final URL lmbaseURL, final File fileDwdZmlN ) throws Exception
  {
    System.out.println( "Start reading raster..." );
    final DWDRasterGeoLayer geoRaster = DWDRasterHelper.loadGeoRaster( lmbaseURL, "EPSG:31468" );
    System.out.println( "Raster read" );

    if( args.length == 2 && args[0].equals( "-rasteroutput" ) )
    {
      final File file = new File( args[1] );
      System.out.println( "Writing raster to file: " + file.getAbsolutePath() );
      geoRaster.saveAsGML( file );
    }

    // raster gml generated
    // start part two and generate mapping configuration
    // N
    FileWriter fileWriter = null;
    try
    {
      fileWriter = new FileWriter( fileDwdZmlN );
      generateDwdZmlConf( geoRaster, DWDRaster.KEY_RAIN, KalypsoStati.BIT_OK, fileWriter );
    }
    finally
    {
      IOUtils.closeQuietly( fileWriter );
    }
  }

  private static void generateDwdZmlConf( final DWDRasterGeoLayer geoRaster, final int dwdKey, final int defaultStatusValue, final Writer writer ) throws Exception
  {
    final GMLWorkspace workspace = GmlSerializer.createGMLWorkspace( DWDConfigure.class.getResource( "../resources/dwd/modell.gml" ) );

    final FeatureType featureType = workspace.getFeatureType( "Einzugsgebiet" );
    final Feature[] features = workspace.getFeatures( featureType );

    final ObjectFactory dwdFac = new ObjectFactory();
    final DwdzmlConf conf = dwdFac.createDwdzmlConf();
    conf.setDefaultStatusValue( defaultStatusValue );
    conf.setDwdKey( dwdKey );
    conf.setNumberOfCells( geoRaster.getNumberOfCells() );
    final List targetList = conf.getTarget();
    for( int i = 0; i < features.length; i++ )
    {
      final Feature feature = features[i];

      final TargetType target = dwdFac.createDwdzmlConfTypeTargetType();

      final TimeseriesLinkType targetZmlLink = (TimeseriesLinkType) feature.getProperty( "Niederschlag_rechnung" );
      target.setTargetZR( targetZmlLink.getHref() );

      final List mapList = target.getMap();
      final GM_Surface surface = (GM_Surface) feature.getProperty( "GEOM_EZG" );
      final double modellArea = GeometryUtilities.calcArea( surface );
      final RasterPart[] positions = geoRaster.getPositions( surface );
      System.out.println( "Feature: " + feature.getId() + " : " + positions.length );
      System.out.println( "A(modell)=" + modellArea );

      // calc full cell area
      double fullCellArea = 0;
      for( int j = 0; j < positions.length; j++ )
        fullCellArea += positions[j].getPortion();

      // set mapping
      if( positions.length == 0 )
        throw new Exception( "für Gebiet " + feature.getId() + " wurden keine Rasterzellen zugeordnet !" );

      for( int j = 0; j < positions.length; j++ )
      {
        final RasterPart rasterPart = positions[j];

        // percentage of intersection
        final double percentage = rasterPart.getPortion() / fullCellArea;

        // round percentage to 2 digits
        final int percent = Math.round( (float) (percentage * 100) );
        if( percent > 0 )
        {
          final MapType map = dwdFac.createDwdzmlConfTypeTargetTypeMapType();
          map.setCellPos( rasterPart.getPosition() );
          map.setFactor( (double) percent / 100 );
          mapList.add( map );
        }
      }

      targetList.add( target );
      System.out.println( "A(cell)=  " + fullCellArea + " deltaA=" + (modellArea - fullCellArea) + " faktor=" + modellArea / fullCellArea );
    }

    final Marshaller marshaller = dwdFac.createMarshaller();
    marshaller.setProperty( Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE );
    marshaller.marshal( conf, writer );
  }
}
