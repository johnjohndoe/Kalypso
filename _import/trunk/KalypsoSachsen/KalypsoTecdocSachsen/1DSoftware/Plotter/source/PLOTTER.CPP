// Plotter.cpp : Defines the class behaviors for the application.
//

#pragma warning(disable:4786)
#pragma warning(disable:4503)

#include "stdafx.h"

#include "wspprj\wspprj.h"

#include "bce\include\wspfeatures.h"
#include "bce\include\wspwin_regentries.h"

#include "commonMfc\include\contextHelp.h"
#include "commonMfc\include\version.h"

#include "profdoc.h"
#include "plotview.h"
#include "template.h"
#include "splash.h"
#include "plotterChildFrame.h"
#include "ipframe.h"
#include "plotfrm.h"
#include "plotterHelpMap.h"
#include "multidoc.h"

#include "plotter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#ifdef _DEBUG
/* static */
log4cpp::Category& CPlotterApp::m_logCat = log4cpp::Category::getInstance( "CPlotterApp" );
#endif _DEBUG;

/////////////////////////////////////////////////////////////////////////////
// CPlotterApp

BEGIN_MESSAGE_MAP(CPlotterApp, CDrawApp)
	//{{AFX_MSG_MAP(CPlotterApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_UPDATE_COMMAND_UI(ID_FILE_MRU_FILE1, OnUpdateRecentFileMenu)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_HELP, OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, OnContextHelp)
	ON_COMMAND(ID_HELP_FINDER, OnHelpFinder)
  ON_COMMAND(ID_DEFAULT_HELP, OnHelpFinder)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPlotterApp construction

CPlotterApp::CPlotterApp() : CDrawApp()
{
	m_pProject = NULL;

	m_nTemplate = -1;
	m_pState = NULL;
	m_nCount = -1;
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CPlotterApp object

CPlotterApp theApp;

// this is the GUID for PLOTTER documents (generated by UUIDGEN.EXE)
static const GUID BASED_CODE clsid =
	{ 0x7e4d6180, 0x853f, 0x11d2, { 0x9a, 0x46, 0, 0x80, 0xad, 0x71, 0xe7, 0xc2 } };
/////////////////////////////////////////////////////////////////////////////
// CPlotterApp initialization

BOOL CPlotterApp::InitInstance()
{
  AfxEnableControlContainer();
	
  if( !CDrawApp::InitInstance() )
		return FALSE;

	SetDefaultIniEntries();

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	InitFeatureInfo();// überprüfen der Einstellungen

	CSplashWnd splash;
	BOOL bSplash = cmdInfo.m_bShowSplash;
	if (!cmdInfo.m_bRunEmbedded)
	{
		switch (m_nCmdShow)
		{
			case SW_HIDE:
			case SW_SHOWMINIMIZED:
			case SW_MINIMIZE:
			case SW_SHOWMINNOACTIVE:
				bSplash = FALSE;
				break;

			case SW_RESTORE:
			case SW_SHOW:
			case SW_SHOWDEFAULT:
			case SW_SHOWNA:
			case SW_SHOWNOACTIVATE:
			case SW_SHOWNORMAL:
			case SW_SHOWMAXIMIZED:
        if( m_bMaximized )
          m_nCmdShow = SW_SHOWMAXIMIZED;
				break;
		}
	}
	else
	{
 		//Excel 4 will start OLE servers minimized
 		m_nCmdShow = SW_SHOWNORMAL;
	}
	clock_t goal, wait = (clock_t) 2 * CLOCKS_PER_SEC;
	if( bSplash )
	{
		// only show splash if not embedded
		splash.Create(NULL);
		splash.ShowWindow(SW_SHOW);
		splash.UpdateWindow();
		goal = wait + clock();
	}
	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	// Template for .prf and .lng Files (OLE Container only)
  CMultiDocTemplate* pProfDocTemplate = new CMultiDocTemplate(
#ifdef _DEBUG
    IDR_PROFDATTYPE_DEBUG,
#else
    IDR_PROFDATTYPE,
#endif
    RUNTIME_CLASS(CProfDatDoc),
    RUNTIME_CLASS(CPlotterChildFrame), // custom MDI child frame
    RUNTIME_CLASS(CPlotterView));
  pProfDocTemplate->SetContainerInfo(IDR_PLOTTERTYPE_CNTR_IP);
	AddDocTemplate( pProfDocTemplate );

	// Template for .wpl Files (OLE Container and Server)
	m_pPlotDocTemplate = new CMultiDocTemplate(
#ifdef _DEBUG
		IDR_PLOTTERTYPE_DEBUG,
#else
		IDR_PLOTTERTYPE,
#endif
		RUNTIME_CLASS(CPlotterDoc),
		RUNTIME_CLASS(CPlotterChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CPlotterView));
	m_pPlotDocTemplate->SetContainerInfo(IDR_PLOTTERTYPE_CNTR_IP);
	m_pPlotDocTemplate->SetServerInfo(
		IDR_PLOTTERTYPE_SRVR_EMB, IDR_PLOTTERTYPE_SRVR_IP,
		RUNTIME_CLASS( CInPlaceFrame ), RUNTIME_CLASS( CPlotterView ) );
	AddDocTemplate( m_pPlotDocTemplate );

  // DokumentTemplate für MultiPlot
  m_pMultiPlotDocTemplate = new CMultiDocTemplate(
    IDR_MULTIPLOTTYPE,
    RUNTIME_CLASS( CMultiDoc ),
    RUNTIME_CLASS( CMDIChildWnd ),
    RUNTIME_CLASS( CDrawView ) );
  AddDocTemplate( m_pMultiPlotDocTemplate );


  m_execDirectory = m_pszHelpFilePath;
  m_execDirectory = m_execDirectory.Left(m_execDirectory.ReverseFind('\\')+1);

	// destroy splash window
	if( bSplash )
	{
		// wait for 2 seconds
		while( goal > clock() )
			;
		splash.DestroyWindow();
	}

	// create main MDI Frame window
	CPlotterFrame* pPlotterFrame = new CPlotterFrame;
	if (!pPlotterFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pPlotterFrame;

  // nachdem der MainFrame erstellt wurde, kann jetzt auch die Online Hilfe initialisiert werden
  CMapUIntToString idMap;
  CPlotterHelpMap::FillHelpMap( idMap );

  CString helpFileName = m_execDirectory + "Plotter.pdf";
  m_pContextHelp->Init( pPlotterFrame, helpFileName, idMap );

	EnableShellOpen();

	// connect the COleTemplate server to the document template
	//  The COleTemplateServer creates new documents on behalf
	//  of requesting OLE containers by using information
	//  specified in the document template.
	m_server.ConnectTemplate(clsid, m_pPlotDocTemplate, FALSE);

	// Register all OLE server factories as running.  This enables the
	//  OLE libraries to create objects from other applications.
	COleTemplateServer::RegisterAll();
		// Note: MDI applications register all class objects regardless of
		//  the /Embedding or /Automation on the command line.

	LoadINISettings();

	// Check to see if launched as OLE server
	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
		COleTemplateServer::RegisterAll();
		AfxOleSetUserCtrl(FALSE);
		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}
	if (cmdInfo.m_nShellCommand==CCommandLineInfo::FileNew)
		cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing;

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	m_server.UpdateRegistry(OAT_INPLACE_SERVER);
	// enable file manager drag/drop and DDE Execute open
	m_pMainWnd->DragAcceptFiles();
	RegisterShellFileTypes(TRUE);
	COleObjectFactory::UpdateRegistryAll();

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;
    
	// The main window has been initialized, so show and update it.
	pPlotterFrame->ShowWindow(m_nCmdShow);
	pPlotterFrame->UpdateWindow();

	return TRUE;
}

void CPlotterApp::SetDefaultIniEntries()
{
	// Den Installationspfad (=Pfad dieser Exe) in die Registry schreiben
	// wird vom WspWin für den Aufruf vom Mapper benutzt
	const CString installPath = GetVersion()->GetFileName();
	if( WriteProfileString( WspWin::REG_KEY_SECTION_INFO, WspWin::REG_KEY_NAME_FILEPATH, LPCTSTR(installPath) ) )
		TRACE( "Wrote install path to registry: " + installPath );
	else
		TRACE( "Could not write install path to registry." );
}

int CPlotterApp::ExitInstance() 
{
	if( m_pProject )
		delete m_pProject;
  
	return CDrawApp::ExitInstance();
}

void CPlotterApp::InitFeatureInfo()
{	// kim
	// ersetzt die FeatureMap durch Vorgabewerte (Demoeinstellung) wenn
	// - die Versionsnummer nicht gültig ist oder
	// - die Registry nicht gelesen werden kann
	// - das Demo-Date erreicht ist

	CString exe_ver = GETPLOTTERAPP->GetVersion()->GetProductNr();


	WSPFeatures* features = WSPFeatures::Instance();

	if( WSPFeatures::Instance()->RegLoaded())
	{
		if( features->isEnabled( "PLOTTER", "plot_nodemo" ) )
		{
			if( !features->CheckDemoDate(features->GetDataStr("PLOTTER","DEMO_DATE")))
			{
				AfxMessageBox("Die aktuelle Lizensierung ist abgelaufen.\nDas Programm wird im DEMO-Modus gestartet.");
				features->SetDataStr("PLOTTER","DEMO_DATE","01.01.2222");//Damit diese Meldung wird nur einmal angezeigt wird
				features->DisableFeature("PLOTTER", "plot_nodemo");
			}
			
			if( !features->CheckRegVer(features->GetDataStr("PLOTTER","VERSIONS_NR"), exe_ver))
			{
				AfxMessageBox("Die vorhandene Lizenz ist nicht für diese Version gültig.\nDas Programm wird im DEMO-Modus gestartet.");
				features->SetDataStr("PLOTTER","VERSIONS_NR",exe_ver);//Damit diese Meldung wird nur einmal angezeigt wird
				features->DisableFeature("PLOTTER", "plot_nodemo");
			}
		}
	}

	if(features->isEnabled("PLOTTER","PRODUCT_NAME")) 
		return;
	
	if(features->AddFeature("PLOTTER","PRODUCT_NAME"))
	{
		features->SetDataStr("PLOTTER","PRODUCT_NAME","Plotter");
		features->EnableFeature("PLOTTER","PRODUCT_NAME");
	}

	AfxMessageBox( "Die Produktregistrierung ist fehlgeschlagen. Das Programm wird im Demo-Modus gestartet." );
};

void CPlotterApp::LoadINISettings()
{
	CString strSection = "Settings";
	BYTE* pb = NULL;
	UINT nLen = 0;

	CDrawApp::LoadINISettings();
	m_nTemplate = GetProfileInt(strSection, "Template", -1 );
} // LoadINISettings

void CPlotterApp::SaveINISettings()
{
	CString strSection = "Settings";

	CDrawApp::SaveINISettings();
	WriteProfileInt(strSection, "Template", m_nTemplate);
} // SaveIniSettings

void CPlotterApp::LoadProject( CString& dir )
{
  CPlotterFrame* plotFrame = NULL;
  if( m_pMainWnd->GetRuntimeClass()->m_lpszClassName == "CPlotterFrame" )
  {
    plotFrame = (CPlotterFrame*)m_pMainWnd;
    plotFrame->CloseProject();
  };

	m_pProject = new Project(dir);
	m_pProject->Load();
	// set the mainframe window title
	if ( m_pMainWnd!=NULL && plotFrame )
		plotFrame->OnUpdateFrameTitle(TRUE);
}; // LoadProject

void CPlotterApp::LoadTemplates()
{
	CFile *pFile;
	CFileException fe;
	CFileStatus rStatus;
	CString path;
	CTemplate *pTemp;
	unsigned int i;
	
	path = m_execDirectory + "template.dat";
	pFile = new CFile;
	if (!pFile->Open(path, CFile::modeRead|CFile::shareDenyWrite, &fe))
	{
		delete pFile;
		return;
	}
    
	CArchive loadArchive(pFile, CArchive::load | CArchive::bNoFlushOnDelete);
	TRY
	{
		CWaitCursor wait;
		if (pFile->GetLength() != 0)
		{
			DWORD nOldSize = loadArchive.ReadCount();
			for (i = 0; i < nOldSize; i++)
			{
				pTemp = new CTemplate;
				loadArchive.m_pDocument = pTemp;
				loadArchive.m_bForceFlat = FALSE;
				pTemp->Serialize(loadArchive);     // load me
				// give each template a NULL section and state
				pTemp->GetSections()->SetAtGrow(0, NULL);
				pTemp->GetStates()->SetAtGrow(0, NULL);
				m_templates.SetAtGrow(i, pTemp);
			}
		}
		loadArchive.Close();
		pFile->Close();
		delete pFile;
	}
	CATCH_ALL(e)
	{
		pFile->Abort();
		delete pFile;

		TRY
		{
			pTemp->ReportSaveLoadException(path, e,
				FALSE, AFX_IDP_FAILED_TO_OPEN_DOC);
		}
		END_TRY
		m_nTemplate = -1;
		pTemp->DeleteContents();
		delete pTemp;
		do
		{
			e->Delete();
		}
		while (0);
		return;
	}
	END_CATCH_ALL
}

BOOL CPlotterApp::SaveTemplates()
{
	CFileException fe;
	CFile* pFile = NULL;
	CFileStatus rStatus;
	CString path, str;
	int i;

	path = m_execDirectory + "template.dat";
	path.MakeUpper();
	pFile = new CFile;
	if (m_templates.GetSize()>0)
	{			// save file
		if (!pFile->Open(path, CFile::modeCreate |
			CFile::modeReadWrite | CFile::shareExclusive, &fe))
		{
			delete pFile;
			m_templates[0]->ReportSaveLoadException(path, &fe,
				TRUE, AFX_IDP_INVALID_FILENAME);
			return FALSE;
		}

		CArchive saveArchive(pFile, CArchive::store | CArchive::bNoFlushOnDelete);
		TRY
		{
			CWaitCursor wait;
			saveArchive.WriteCount(m_templates.GetSize());
			for (i=0; i<m_templates.GetSize(); i++)
			{
				saveArchive.m_pDocument = m_templates[i];
				saveArchive.m_bForceFlat = FALSE;
				m_templates[i]->Serialize(saveArchive);     // save me
				m_templates[i]->SetModifiedFlag(FALSE);
			}
			saveArchive.Close();
			pFile->Close();
			delete pFile;
		}
		CATCH_ALL(e)
		{
			pFile->Abort();
			delete pFile;
	
			TRY
			{
				m_templates[0]->ReportSaveLoadException(path, e,
					TRUE, AFX_IDP_FAILED_TO_SAVE_DOC);
			}
			END_TRY
			do
			{
				e->Delete();
			}
			while (0);
			return FALSE;
		}
		END_CATCH_ALL
	}
	else
	{
		TRY		// delete file
		{
			if (pFile->GetStatus(path, rStatus))
				pFile->Remove(path);
			delete pFile;
		}
		CATCH( CFileException, e )
		{
			str.FormatMessage(AFX_IDP_FILE_ACCESS_DENIED, path);
			AfxMessageBox(str);
			delete pFile;
			return FALSE;
		}
		END_CATCH

	}
	
	return TRUE;
}

void CPlotterApp::FlushTemplates()
{
	int i;
	CTemplate *pTemp;
	
	for (i=0; i<m_templates.GetSize(); i++)
	{
		pTemp = m_templates.GetAt(i);
		pTemp->DeleteContents();
		delete pTemp;
	}
	m_templates.RemoveAll();
}

int CPlotterApp::GetImageType( int nType )
{
  return DataBlock::GetImageType( nType );
}

void CPlotterApp::GetDrawingFileName(CString& path, Section* sec)
{
	CString filename, ext, str;

	if (sec!=NULL)
	{
		if (sec->GetClassType()==CLASS_TYPE_LSECTION)
		{
      // es können mehrere Längschnitte mit dem gleichen Title ( Name ohne ext ) exisiteren ( Berechnungsvars. )
      // deswegen muss eine neue ( eindeutige ) Nummer codiert werden aus Titel und Ext.
			filename = sec->GetFileTitle();
			ext = sec->GetFileExt();
			if (filename.IsEmpty())
				filename = "Plotter";
			if (filename.GetLength()==8 && ext.GetLength()==3)
			{
				str = filename.Right(4);
				str += ext;
				if (str.SpanIncluding("0123456789")==str)
				{
					ext.Format("%06x", atoi(str));
					filename = filename.Left(2);
					filename += ext;
				}
			}
			filename = "Plot_ls\\" + filename;
		}
		else
		{
			filename = sec->GetFileTitle();
			if (filename.IsEmpty())
				filename = "Plotter";
			filename = "Plot_qp\\" + filename;
		}
	}
	else
	{
		path.Empty();
		return;
	}
	filename += ".wpl";
	path = m_pProject->GetDir();
	path += "\\" + filename;
} // GetDrawingFileName

void CPlotterApp::DeleteProject()
{
  delete m_pProject; m_pProject = NULL; 
};


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BOOL CAboutDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	CString strFreeDiskSpace;
	CString strFreeMemory;
	CString strFmt;

  SetWindowText( CString( MAKEINTRESOURCE( IDS_ABOUT_TITLE ) ) );

  // falls nicht Demo, Demo-Text löschen
	if (WSPFeatures::Instance()->isEnabled("PLOTTER","plot_nodemo"))
    GetDlgItem( IDC_DEMO_TEXT )->SetWindowText( TEXT("") );
	
  // Texte für Speicher setzen
  GetDlgItem( IDC_PHYSICAL_MEM_TEXT )->SetWindowText( CString( MAKEINTRESOURCE(IDS_PHYSICAL_MEM_TEXT) ) );
  GetDlgItem( IDC_DISK_SPACE_TEXT )->SetWindowText( CString( MAKEINTRESOURCE(IDS_DISK_SPACE_TEXT) ) );

  CString version = TEXT("WspWin Plotter, Version ") + GETPLOTTERAPP->GetVersion()->GetProductNr();
  GetDlgItem( IDC_STATIC3 )->SetWindowText( version );




	// Verfügbaren Speicher abrufen
	MEMORYSTATUS MemStat;
	MemStat.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&MemStat);
	strFmt.LoadString(IDS_PHYSICAL_MEM);
	strFreeMemory.Format(strFmt, MemStat.dwTotalPhys / 1024L);
	
	SetDlgItemText(IDC_PHYSICAL_MEM, strFreeMemory);
	
	// Informationen über Festplattenspeicher abrufen
	struct _diskfree_t diskfree;
	int nDrive = _getdrive(); // aktuelles Standardlaufwerk verwenden
	if (_getdiskfree(nDrive, &diskfree) == 0)
	{
		strFmt.LoadString(IDS_DISK_SPACE);
		strFreeDiskSpace.Format(strFmt,
			(DWORD)diskfree.avail_clusters *
			(DWORD)diskfree.sectors_per_cluster *
			(DWORD)diskfree.bytes_per_sector / (DWORD)1024L,
			nDrive-1 + _T('A'));
	}
	else
		strFreeDiskSpace.LoadString(IDS_DISK_SPACE_UNAVAIL);
	
	SetDlgItemText(IDC_DISK_SPACE, strFreeDiskSpace);

  UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX-Eigenschaftenseiten sollten FALSE zurückgeben
}

// App command to run the dialog
void CPlotterApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CPlotterApp commands

BOOL CPlotterApp::OnDDECommand(LPTSTR lpszCommand) 
{
   if (CDrawApp::OnDDECommand(lpszCommand))
      return TRUE;

	CString strCommand = lpszCommand;
	CString strProject, strState, strSection;
	State *st;
	Section *sec;

	// open project format is "[project("%s","%s","%s")]" - no whitespace allowed, one per line
	CCommandLineInfo cmdInfo;
	strCommand.MakeLower();

	if (strCommand.Left(10) == _T("[project(\""))
	{
		strCommand = strCommand.Right(strCommand.GetLength() - 10);

		int i = strCommand.Find('"');
		if (i == -1)
			return FALSE; // illegally terminated

		strProject = strCommand.Left(i);
		strCommand = strCommand.Right(strCommand.GetLength() - i);

		// If we were started up for DDE retrieve the Show state
		if (m_pCmdInfo != NULL)
		{
			m_nCmdShow = (int)m_pCmdInfo;
			m_pCmdInfo = NULL;
		}

		// show the application window
		CWnd* pMainWnd = m_pMainWnd;
		int nCmdShow = m_nCmdShow;
		if (nCmdShow == -1 || nCmdShow == SW_SHOWNORMAL)
		{
			if (pMainWnd->IsIconic())
				nCmdShow = SW_RESTORE;
			else
				nCmdShow = SW_SHOW;
		}
		pMainWnd->ShowWindow(nCmdShow);
		if (nCmdShow != SW_MINIMIZE)
			pMainWnd->SetForegroundWindow();

		((CPlotterFrame*)pMainWnd)->CloseProject();
		// then open the project
		LoadProject(strProject);

		if (m_pProject==NULL)
			return FALSE;

		// user is now "in control" of the application
		if (!AfxOleGetUserCtrl())
			AfxOleSetUserCtrl(TRUE);

		// next time, show the window as default
		m_nCmdShow = -1;

		if (strCommand.Left(3) != _T("\",\""))
			return TRUE; // no state given
		else
		{
			strCommand = strCommand.Right(strCommand.GetLength() - 3);
			i = strCommand.Find('"');
			if (i == -1)
				return FALSE; // illegally terminated
			else
			{
				strState = strCommand.Left(i);
				strCommand = strCommand.Right(strCommand.GetLength() - i);
			}
		}

		if (strCommand.Left(3) != _T("\",\""))
			return FALSE; // no section given
		else
		{
			strCommand = strCommand.Right(strCommand.GetLength() - 3);
			i = strCommand.Find('"');
			if (i == -1)
				return FALSE; // illegally terminated
			else
			{
				cmdInfo.m_nShellCommand = CCommandLineInfo::FileOpen;
				strSection = strCommand.Left(i);
				strCommand = strCommand.Right(strCommand.GetLength() - i);
			}
		}

		st = m_pProject->GetFirstState();
		while (st!=NULL)
		{
			CString fileName;

			fileName = st->GetFileName();
			fileName.MakeLower();
			if (fileName==strState)
				break;
			st = m_pProject->GetNextState();
		}
		if (st==NULL)
			return FALSE;
		
		LengthSection *ls;
		Calculation *calc;

		sec = NULL;
		
		calc = st->GetFirstCalculation();
		while (calc!=NULL)
		{
			CString fileName;

			ls = calc->GetLengthSection();
			if (ls!=NULL)
			{
				fileName = ls->GetFileName();
				fileName.MakeLower();
				if (fileName==strSection)
				{
					sec = ls;		// we have a length section
					break;
				}

			}
			calc = st->GetNextCalculation();
		}
		if (sec==NULL)
		{
			Section *cs;
			
			cs = st->GetFirstCrossSection();
			while (cs!=NULL)
			{
				CString fileName;
				
				fileName = cs->GetFileName();
				fileName.MakeLower();
				if (fileName==strSection)
				{
					sec = cs;
					break;
				}
				cs = st->GetNextCrossSection();
			}
		}

		if (sec==NULL)
			return FALSE;

		m_pState = st;
		m_Sections.RemoveAll();
		m_Sections.SetAtGrow(0, sec);
		m_nCount = 0;

		GetDrawingFileName(cmdInfo.m_strFileName, sec);

		// then open the profile
		OpenDocumentFile(cmdInfo.m_strFileName);

		return TRUE;
	}

  // Return FALSE for any unhandled DDE commands.
  return FALSE;
}

void CPlotterApp::OnUpdateRecentFileMenu(CCmdUI* pCmdUI)
{
	CFileStatus rStatus;

  for( int i = 0; i < m_pRecentFileList->GetSize(); i++ )
	{
    if (!m_pRecentFileList->m_arrNames[i].IsEmpty())
    {
      if (!CFile::GetStatus(m_pRecentFileList->m_arrNames[i], rStatus))
        m_pRecentFileList->Remove(i--);
    }
  }

  CDrawApp::OnUpdateRecentFileMenu(pCmdUI);
}

void CPlotterApp::CreateMultiPlot( const SectionArray& secArray, BOOL bAutoFileName )
{
  // nur ein neues Dokument diesen Typs erzeugen
  CMultiDoc* pMultiDoc = (CMultiDoc*)m_pMultiPlotDocTemplate->OpenDocumentFile( 0 );
  if( pMultiDoc )
    pMultiDoc->SetSections( secArray );
}
