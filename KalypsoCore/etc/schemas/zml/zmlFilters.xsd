<?xml version="1.0" encoding="UTF-8"?>
<schema targetNamespace="filters.zml.kalypso.org" elementFormDefault="qualified" attributeFormDefault="unqualified" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:xlinkext="http://www.w3.org/1999/xlinkext" xmlns:filters="filters.zml.kalypso.org" xmlns:vc="valuecomp.filters.zml.kalypso.org">
	<import namespace="http://www.w3.org/1999/xlinkext" schemaLocation="../xlink/xlinksext.xsd"/>
	<import namespace="valuecomp.filters.zml.kalypso.org" schemaLocation="./zmlFiltersValueComp.xsd"/>
	
	<!-- filter hierarchy base type -->
	<complexType name="abstractFilterType" abstract="true"/>
	<element name="filter" type="filters:abstractFilterType"/>
	
	<!-- Filter: WQ Transformation -->
	<complexType name="wqFilterType">
		<complexContent>
			<extension base="filters:abstractFilterType">
				<sequence>
					<element ref="filters:filter" minOccurs="0"/>
				</sequence>
				<!-- W or Q -->
				<attribute name="type" type="string"/>
			</extension>
		</complexContent>
	</complexType>
	<element name="wqFilter" type="filters:wqFilterType" substitutionGroup="filters:filter"/>
	
	<!-- Filter: valueFilter -->
	<complexType name="valueFilterType">
		<complexContent>
			<extension base="filters:abstractFilterType">
				<sequence>
					<element ref="vc:valueComp" minOccurs="0" maxOccurs="unbounded"/>
					<element ref="filters:filter" minOccurs="0"/>
				</sequence>
			</extension>
		</complexContent>
	</complexType>
	<element name="valueFilter" type="filters:valueFilterType" substitutionGroup="filters:filter"/>
	
	<!-- Filter: Math Operation on values -->
	<complexType name="operationFilterType">
		<complexContent>
			<extension base="filters:abstractFilterType">
				<sequence>
					<element ref="filters:filter" minOccurs="0"/>
				</sequence>
				<attribute name="operator" type="string"/>
				<attribute name="operand" type="string"/>
			</extension>
			<!-- +,-,/,*-->
			<!-- e.g. 5 -->
		</complexContent>
	</complexType>
	<element name="operationFilter" type="filters:operationFilterType" substitutionGroup="filters:filter"/>
	
	<!-- Filter: Math Operation between Filters -->
	<complexType name="nOperationFilterType">
		<complexContent>
			<extension base="filters:abstractFilterType">
				<sequence>
					<element ref="filters:filter" maxOccurs="unbounded"/>
				</sequence>
				<attribute name="operator" type="string"/>
			</extension>
			<!-- +, -, *, / oder min, max, avg ... -->
		</complexContent>
	</complexType>
	<element name="nOperationFilter" type="filters:nOperationFilterType" substitutionGroup="filters:filter"/>

	<!-- Filter: interpolation (interpolates the values using the date axis (ascending order) ) -->	
	<complexType name="interpolationFilterType">
		<complexContent>
			<extension base="filters:abstractFilterType">
				<sequence>
					<element ref="filters:filter" minOccurs="0"/>
				</sequence>
				<!-- which field of the date will be used for steping through the timeserie -->
				<attribute type="string" name="calendarField"/>
				<!-- amount of time for the step -->
				<attribute type="int" name="amount"/>
				<!-- when true, fills the model with defaultValue when no base value -->
				<attribute type="boolean" name="forceFill"/>
				<!-- default value to use when filling absent values -->
				<attribute type="double" name="defaultValue"/>
				<!-- value of the default status when no base status -->
				<attribute type="int" name="defaultStatus"/>
			</extension>
		</complexContent>
	</complexType>
	<element name="interpolationFilter" type="filters:interpolationFilterType" substitutionGroup="filters:filter" />

	<!-- Filter: datahole (detects hole in the data and sets the status accordingly) -->
	<complexType name="dataholeFilterType">
		<complexContent>
			<extension base="filters:abstractFilterType">
				<sequence>
					<element ref="filters:filter" minOccurs="0"/>
				</sequence>
				<!-- invalid value that must be checked (for instance -999) -->
				<attribute name="value" type="double"/>
				<!-- value of the status to generate if an invalid value is found -->
				<attribute name="status" type="int"/>
				<!-- if true, the value of replaceWith will be used instead of the original value -->
				<attribute name="replace" type="boolean" use="optional" default="false" />
				<!-- the value will be replaced by this one -->
				<attribute name="replaceWith" type="double" use="optional"/>
			</extension>
		</complexContent>
	</complexType>
	<element name="dataholeFilter" type="filters:dataholeFilterType" substitutionGroup="filters:filter"/>

	<!-- Filter: forecast (merges the tupples on the date axis in ascending order) -->	
	<complexType name="forecastFilterType">
		<complexContent>
			<extension base="filters:abstractFilterType">
				<sequence>
					<element ref="filters:filter" minOccurs="1" maxOccurs="unbounded"/>
				</sequence>
			</extension>
		</complexContent>
	</complexType>
	<element name="forecastFilter" type="filters:forecastFilterType" substitutionGroup="filters:filter" />
	
	<!-- Filter: ZML-Link -->
	<complexType name="zmlFilterType">
		<complexContent>
			<extension base="filters:abstractFilterType">
				<sequence>
					<element name="zml" type="xlinkext:SimpleLinkType"/>
				</sequence>
			</extension>
		</complexContent>
	</complexType>
	<element name="zmlFilter" type="filters:zmlFilterType" substitutionGroup="filters:filter"/>
	
</schema>
